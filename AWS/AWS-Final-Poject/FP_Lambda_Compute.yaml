AWSTemplateFormatVersion: '2010-09-09'
Description: 'This template defines the serverless compute layer of the project. It connects the ingestion pipeline (API Gateway + Kinesis) to the data stores (DynamoDB + S3) by running validation, enrichment, and aggregation logic inside Lambda functions. It also sets up failure handling and retries.'

Resources:
####################
# Lambda Functions #
####################

  ValidatorEnricherLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: validator_enricher
      Description: 'Validates and enriches incoming events'
      Runtime: 'python3.13' # Maybe need to be change the runtime environment python3.12
      Handler: 'index.validator'
      DeadLetterConfig:
        TargetArn: !GetAtt ValidatorDLQ.Arn
      Role: arn:aws:iam::937115287175:role/All-Mighty-Lambda # Make a yaml file for the role
      Code:
        ZipFile: |
          import json
          import base64
          from datetime import datetime

          def validator(event, context):
              """
              Validator Lambda:
              - Decodes base64 Kinesis payloads
              - Validates required fields (symbol, price)
              - Enriches with timestamp
              - Logs bad records
              """
              output = []
              for record in event.get("Records", []):
                  try:
                      # Decode Base64
                      payload = base64.b64decode(record["kinesis"]["data"]).decode("utf-8")
                      data = json.loads(payload)

                      # Validate fields
                      if "symbol" not in data or "price" not in data:
                          raise ValueError("Missing required fields")

                      # Enrich
                      data["validated_at"] = datetime.utcnow().isoformat()
                      output.append(data)

                  except Exception as e:
                      print(f"Bad record skipped: {e}")

              print(f"Validated batch: {output}")
              return output

  AggregatorLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: aggregator
      Description: 'Aggregates events for batch processing'
      Runtime: 'python3.13' # Maybe need to be change the runtime environment python3.12
      Handler: 'index.aggregator'
      Role: arn:aws:iam::937115287175:role/All-Mighty-Lambda # Make a yaml file for the role
      DeadLetterConfig:
        TargetArn: !GetAtt AggregatorDLQ.Arn
      Code:
        ZipFile: |
          import json
          import base64

          def aggregator(event, context):
              """
              Aggregator Lambda:
              - Reads validated events
              - Groups by 'symbol' (or 'city')
              - Computes average price per group
              """
              aggregates = {}

              for record in event.get("Records", []):
                  try:
                      payload = base64.b64decode(record["kinesis"]["data"]).decode("utf-8")
                      data = json.loads(payload)

                      key = data.get("symbol") or data.get("city")
                      price = data.get("price")

                      if key and isinstance(price, (int, float)):
                          if key not in aggregates:
                              aggregates[key] = []
                          aggregates[key].append(price)

                  except Exception as e:
                      print(f"Error processing record: {e}")

              results = {k: sum(v) / len(v) for k, v in aggregates.items() if v}
              print(f"Aggregated results: {results}")
              return results

####################
#  Event Sources   #
####################

  KinesisStream:
    Type: AWS::Kinesis::Stream
    Properties:
      Name: KinesisStream
      ShardCount: 1 # Each shard gives you: 1 MB/sec write throughput, 2 MB/sec read throughput, Up to 1,000 records per second

  ValidatorEnricherEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt KinesisStream.Arn
      FunctionName: !Ref ValidatorEnricherLambda
      StartingPosition: LATEST # Process only new incoming events from now on
      BatchSize: 10
      Enabled: true

  AggregatorEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt KinesisStream.Arn
      FunctionName: !Ref AggregatorLambda
      StartingPosition: LATEST # Process only new incoming events from now on
      BatchSize: 10
      Enabled: true

##################
#   SQS Queues   #
##################

# If a batch fails, you want to capture the raw event payloads for debugging or manual reprocessing.

  ValidatorDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: validator_dlq
      VisibilityTimeout: 60 # 1 minute

  AggregatorDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: aggregator_dlq
      VisibilityTimeout: 60 # 1 minute

##################
#    Outputs     #
##################

Outputs:

  ValidatorEnricherLambda:
    Description: 'Validator and Enricher Lambda Function'
    Value: !Ref ValidatorEnricherLambda
    Export:
      Name: !Sub "${AWS::StackName}-ValidatorEnricherLambda"

  AggregatorLambda:
    Description: 'Aggregator Lambda Function'
    Value: !Ref AggregatorLambda
    Export:
      Name: !Sub "${AWS::StackName}-AggregatorLambda"

  KinesisStream:
    Description: 'Kinesis Stream'
    Value: !Ref KinesisStream
    Export:
      Name: !Sub "${AWS::StackName}-KinesisStream"

  ValidatorDLQUrl:
    Description: 'URL of the Validator Dead Letter Queue'
    Value: !Ref ValidatorDLQ
    Export:
      Name: !Sub "${AWS::StackName}-ValidatorDLQUrl"

  AggregatorDLQUrl:
    Description: 'URL of the Aggregator Dead Letter Queue'
    Value: !Ref AggregatorDLQ
    Export:
      Name: !Sub "${AWS::StackName}-AggregatorDLQUrl"

# ==============================
#   TO-DO LIST: MOVE KINESIS & SQS TO STEP 3
# ==============================

# üì¶ Kinesis Stream
# [ ] Move "KinesisStream" resource from compute.yaml ‚Üí ingestion.yaml.
# [ ] In compute.yaml, replace with a Parameter:
#       Parameters:
#         KinesisStreamArn:
#           Type: String
#           Description: ARN of the ingestion Kinesis stream
# [ ] Update EventSourceMappings in compute.yaml to use:
#       EventSourceArn: !Ref KinesisStreamArn

# üì¨ Dead Letter Queues (DLQs)
# [ ] Move "ValidatorDLQ" and "AggregatorDLQ" resources from compute.yaml ‚Üí ingestion.yaml.
# [ ] In compute.yaml, replace with Parameters:
#       ValidatorDLQArn:
#         Type: String
#         Description: ARN of the Validator DLQ
#       AggregatorDLQArn:
#         Type: String
#         Description: ARN of the Aggregator DLQ
# [ ] Update DeadLetterConfig in each Lambda to use:
#       DeadLetterConfig:
#         TargetArn: !Ref ValidatorDLQArn
#         TargetArn: !Ref AggregatorDLQArn

# üìä Outputs (Step 3)
# [ ] In ingestion.yaml, export Outputs for:
#       - KinesisStreamArn
#       - ValidatorDLQArn
#       - AggregatorDLQArn
# [ ] In compute.yaml, import with:
#       Parameters + cross-stack reference (Fn::ImportValue).


# ==============================
#   TO-DO LIST FOR COMPUTE.YAML
# ==============================

# üîê IAM Roles
# [ ] Create separate IAM roles for each Lambda (AWS::IAM::Role).
#     - Validator Role ‚Üí dynamodb:PutItem, s3:PutObject, logs:* 
#     - Aggregator Role ‚Üí dynamodb:UpdateItem, logs:*
# [ ] Replace the placeholder "All-Mighty-Lambda" ARN with these roles.

# üìú Permissions
# [ ] Add AWS::Lambda::Permission if EventBridge Scheduler or S3 events 
#     are later used to invoke Lambdas (not needed for Kinesis mappings).

# üì¶ S3 Integration (Step 2)
# [ ] Add S3 buckets:
#     - raw/ ‚Üí unprocessed events
#     - processed/ ‚Üí Validator writes cleaned data here
# [ ] Update Validator Lambda IAM role with s3:PutObject permissions.


# üóÑ DynamoDB Integration (Step 5)
# [ ] Connect Validator and Aggregator Lambdas to DynamoDB Global Tables.
# [ ] Update IAM roles with dynamodb:PutItem / dynamodb:UpdateItem access.

# ‚è± Lambda Settings
# [ ] Explicitly set Timeout for both Lambdas (instead of default 3s).
#     - Validator ‚Üí ~30s
#     - Aggregator ‚Üí ~60s
# [ ] Adjust DLQ VisibilityTimeout (best practice = 6√ó Lambda timeout).

# ==============================
#       END OF TO-DO LIST
# ==============================